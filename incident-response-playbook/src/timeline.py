"""
Incident Timeline Generator
=============================

Creates, manages, and formats incident timelines with realistic timestamps.
Supports automatic timeline generation for simulation scenarios and manual
event addition for real incident tracking.
"""

from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional
import random

from src.models import TimelineEvent


class TimelineGenerator:
    """Generates and manages incident response timelines."""

    # Realistic time offsets for automated timeline generation (minutes)
    PHASE_DURATIONS = {
        "detection": {
            "alert_generated": (0, 0),
            "alert_reviewed": (2, 15),
            "alert_validated": (10, 30),
            "soc_escalation": (15, 45),
        },
        "triage": {
            "ir_team_activated": (20, 60),
            "initial_scoping": (30, 90),
            "severity_classified": (40, 120),
            "executive_notified": (45, 130),
        },
        "containment": {
            "containment_plan_approved": (60, 180),
            "short_term_containment": (70, 210),
            "evidence_preserved": (80, 240),
            "long_term_containment": (120, 360),
        },
        "eradication": {
            "root_cause_identified": (180, 720),
            "malware_removed": (240, 960),
            "vulnerabilities_patched": (300, 1200),
            "eradication_verified": (360, 1440),
        },
        "recovery": {
            "systems_restored": (420, 2880),
            "monitoring_enhanced": (480, 2880),
            "validation_complete": (540, 4320),
            "normal_operations": (600, 4320),
        },
        "post_incident": {
            "lessons_learned_scheduled": (720, 10080),
            "report_drafted": (1440, 20160),
            "improvements_planned": (2880, 30240),
            "case_closed": (4320, 43200),
        },
    }

    EVENT_DESCRIPTIONS = {
        "alert_generated": "Security monitoring alert generated by {source}",
        "alert_reviewed": "SOC Tier-1 analyst reviewed incoming alert",
        "alert_validated": "Alert validated as true positive through {method}",
        "soc_escalation": "Alert escalated to Incident Response team per escalation matrix",
        "ir_team_activated": "IR team activated; Incident Commander designated: {commander}",
        "initial_scoping": "Initial scope assessment: {scope_summary}",
        "severity_classified": "Incident severity classified as {severity}",
        "executive_notified": "Executive leadership and stakeholders notified",
        "containment_plan_approved": "Containment strategy approved by Incident Commander",
        "short_term_containment": "Short-term containment measures implemented: {measures}",
        "evidence_preserved": "Volatile and non-volatile evidence collected and preserved",
        "long_term_containment": "Long-term containment measures in place; attacker access severed",
        "root_cause_identified": "Root cause analysis complete: {root_cause}",
        "malware_removed": "All identified malicious artifacts removed from affected systems",
        "vulnerabilities_patched": "Exploited vulnerabilities patched and verified",
        "eradication_verified": "Eradication verified through integrity checks and threat hunting",
        "systems_restored": "Affected systems restored to operational status",
        "monitoring_enhanced": "Enhanced monitoring deployed for post-recovery observation",
        "validation_complete": "Post-recovery validation complete; no residual indicators detected",
        "normal_operations": "Normal business operations resumed",
        "lessons_learned_scheduled": "Post-incident review meeting scheduled",
        "report_drafted": "Formal incident report drafted and under review",
        "improvements_planned": "Improvement recommendations documented and assigned",
        "case_closed": "Incident case officially closed",
    }

    def __init__(self):
        self.events: List[TimelineEvent] = []

    def generate_scenario_timeline(
        self,
        incident_start: Optional[datetime] = None,
        scenario_type: str = "generic",
        include_details: bool = True,
        **kwargs,
    ) -> List[TimelineEvent]:
        """
        Generate a realistic incident timeline with proper timestamps.

        Args:
            incident_start: Base timestamp for the incident. Defaults to now.
            scenario_type: Type of scenario for contextual descriptions.
            include_details: Whether to include detailed event descriptions.
            **kwargs: Additional context for event descriptions (commander, severity, etc.).

        Returns:
            Ordered list of TimelineEvent objects.
        """
        base_time = incident_start or datetime.now()
        timeline = []

        defaults = {
            "source": "SIEM Correlation Engine",
            "method": "log correlation and IOC matching",
            "commander": "On-call IR Lead",
            "scope_summary": "Multiple systems affected; investigation ongoing",
            "severity": "High",
            "measures": "Network isolation and credential rotation",
            "root_cause": "Under investigation",
        }
        defaults.update(kwargs)

        for phase_name, events in self.PHASE_DURATIONS.items():
            for event_key, (min_offset, max_offset) in events.items():
                offset_minutes = random.randint(min_offset, max_offset)
                event_time = base_time + timedelta(minutes=offset_minutes)

                description = self.EVENT_DESCRIPTIONS.get(event_key, event_key)
                if include_details:
                    try:
                        description = description.format(**defaults)
                    except KeyError:
                        pass

                event = TimelineEvent(
                    timestamp=event_time,
                    event_type=event_key,
                    description=description,
                    actor=self._get_actor_for_event(event_key),
                    source=self._get_source_for_event(event_key),
                    phase=phase_name,
                    is_automated=event_key in ("alert_generated",),
                )
                timeline.append(event)

        # Sort by timestamp
        timeline.sort(key=lambda e: e.timestamp)
        self.events = timeline
        return timeline

    def add_event(self, event: TimelineEvent) -> None:
        """Add a single event to the timeline."""
        self.events.append(event)
        self.events.sort(key=lambda e: e.timestamp)

    def add_custom_event(
        self,
        description: str,
        phase: str,
        actor: str = "",
        event_type: str = "custom",
        timestamp: Optional[datetime] = None,
    ) -> TimelineEvent:
        """Create and add a custom event to the timeline."""
        event = TimelineEvent(
            timestamp=timestamp or datetime.now(),
            event_type=event_type,
            description=description,
            actor=actor,
            phase=phase,
        )
        self.add_event(event)
        return event

    def get_events_by_phase(self, phase: str) -> List[TimelineEvent]:
        """Filter timeline events by IR phase."""
        return [e for e in self.events if e.phase == phase]

    def get_events_in_range(self, start: datetime, end: datetime) -> List[TimelineEvent]:
        """Filter timeline events within a time range."""
        return [e for e in self.events if start <= e.timestamp <= end]

    def get_duration(self) -> Optional[timedelta]:
        """Calculate total timeline duration from first to last event."""
        if len(self.events) < 2:
            return None
        return self.events[-1].timestamp - self.events[0].timestamp

    def get_phase_durations(self) -> Dict[str, timedelta]:
        """Calculate duration of each IR phase."""
        phase_times: Dict[str, Dict[str, datetime]] = {}
        for event in self.events:
            phase = event.phase
            if phase not in phase_times:
                phase_times[phase] = {"start": event.timestamp, "end": event.timestamp}
            else:
                phase_times[phase]["end"] = max(phase_times[phase]["end"], event.timestamp)

        return {
            phase: times["end"] - times["start"]
            for phase, times in phase_times.items()
        }

    def get_mean_time_to_contain(self) -> Optional[timedelta]:
        """Calculate Mean Time to Contain (MTTC) from detection to containment."""
        detection_events = self.get_events_by_phase("detection")
        containment_events = self.get_events_by_phase("containment")

        if detection_events and containment_events:
            first_detection = min(e.timestamp for e in detection_events)
            last_containment = max(e.timestamp for e in containment_events)
            return last_containment - first_detection
        return None

    def get_mean_time_to_recover(self) -> Optional[timedelta]:
        """Calculate Mean Time to Recover (MTTR) from detection to recovery."""
        detection_events = self.get_events_by_phase("detection")
        recovery_events = self.get_events_by_phase("recovery")

        if detection_events and recovery_events:
            first_detection = min(e.timestamp for e in detection_events)
            last_recovery = max(e.timestamp for e in recovery_events)
            return last_recovery - first_detection
        return None

    def format_timeline(self) -> str:
        """Format the timeline as a human-readable string."""
        if not self.events:
            return "No timeline events recorded."

        lines = ["INCIDENT TIMELINE", "=" * 70]
        current_phase = ""

        for event in self.events:
            if event.phase != current_phase:
                current_phase = event.phase
                lines.append(f"\n--- {current_phase.upper().replace('_', ' ')} ---")

            timestamp_str = event.timestamp.strftime("%Y-%m-%d %H:%M:%S UTC")
            actor_str = f" [{event.actor}]" if event.actor else ""
            auto_str = " (automated)" if event.is_automated else ""

            lines.append(f"  {timestamp_str}{actor_str}{auto_str}")
            lines.append(f"    {event.description}")

        # Summary metrics
        duration = self.get_duration()
        mttc = self.get_mean_time_to_contain()
        mttr = self.get_mean_time_to_recover()

        lines.append(f"\n{'=' * 70}")
        lines.append("TIMELINE METRICS")
        if duration:
            lines.append(f"  Total Duration: {self._format_timedelta(duration)}")
        if mttc:
            lines.append(f"  Mean Time to Contain (MTTC): {self._format_timedelta(mttc)}")
        if mttr:
            lines.append(f"  Mean Time to Recover (MTTR): {self._format_timedelta(mttr)}")

        return "\n".join(lines)

    def to_list_of_dicts(self) -> List[Dict[str, Any]]:
        """Serialize all events for reporting."""
        return [e.to_dict() for e in self.events]

    @staticmethod
    def _get_actor_for_event(event_key: str) -> str:
        """Return a realistic actor name for the event type."""
        actor_map = {
            "alert_generated": "SIEM",
            "alert_reviewed": "SOC Tier-1 Analyst",
            "alert_validated": "SOC Tier-2 Analyst",
            "soc_escalation": "SOC Manager",
            "ir_team_activated": "Incident Commander",
            "initial_scoping": "IR Lead Analyst",
            "severity_classified": "Incident Commander",
            "executive_notified": "Incident Commander",
            "containment_plan_approved": "Incident Commander",
            "short_term_containment": "IR Containment Team",
            "evidence_preserved": "Digital Forensics Analyst",
            "long_term_containment": "IR Containment Team",
            "root_cause_identified": "IR Lead Analyst",
            "malware_removed": "IR Eradication Team",
            "vulnerabilities_patched": "Vulnerability Management",
            "eradication_verified": "Threat Hunter",
            "systems_restored": "IT Operations",
            "monitoring_enhanced": "SOC Engineering",
            "validation_complete": "IR Lead Analyst",
            "normal_operations": "IT Operations Manager",
            "lessons_learned_scheduled": "Incident Commander",
            "report_drafted": "IR Lead Analyst",
            "improvements_planned": "Security Architecture",
            "case_closed": "Incident Commander",
        }
        return actor_map.get(event_key, "IR Team")

    @staticmethod
    def _get_source_for_event(event_key: str) -> str:
        """Return the source system for the event type."""
        source_map = {
            "alert_generated": "SIEM",
            "alert_reviewed": "Ticketing System",
            "alert_validated": "SIEM / EDR",
            "soc_escalation": "Escalation Matrix",
            "ir_team_activated": "IR Platform",
            "evidence_preserved": "Forensic Workstation",
        }
        return source_map.get(event_key, "IR Case Management")

    @staticmethod
    def _format_timedelta(td: timedelta) -> str:
        """Format a timedelta as a human-readable string."""
        total_seconds = int(td.total_seconds())
        days = total_seconds // 86400
        hours = (total_seconds % 86400) // 3600
        minutes = (total_seconds % 3600) // 60

        parts = []
        if days > 0:
            parts.append(f"{days}d")
        if hours > 0:
            parts.append(f"{hours}h")
        if minutes > 0:
            parts.append(f"{minutes}m")
        return " ".join(parts) if parts else "< 1m"
