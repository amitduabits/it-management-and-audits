"""
Core data models for the Incident Response Playbook Engine.

Defines structured representations of incidents, alerts, evidence items,
timeline events, and response actions using Python dataclasses.
All models follow industry-standard IR terminology and NIST SP 800-61 conventions.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import List, Optional, Dict, Any
import uuid


class SeverityLevel(Enum):
    """Incident severity classification per organizational severity matrix."""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFORMATIONAL = "informational"


class IncidentStatus(Enum):
    """Incident lifecycle status aligned with NIST SP 800-61 phases."""
    NEW = "new"
    TRIAGED = "triaged"
    INVESTIGATING = "investigating"
    CONTAINING = "containing"
    ERADICATING = "eradicating"
    RECOVERING = "recovering"
    CLOSED = "closed"
    POST_INCIDENT = "post_incident"


class IncidentCategory(Enum):
    """NIST-aligned incident category taxonomy."""
    DATA_BREACH = "data_breach"
    RANSOMWARE = "ransomware"
    PHISHING = "phishing"
    DDOS = "ddos"
    INSIDER_THREAT = "insider_threat"
    MALWARE = "malware"
    UNAUTHORIZED_ACCESS = "unauthorized_access"
    WEB_APPLICATION_ATTACK = "web_application_attack"
    SUPPLY_CHAIN = "supply_chain"
    OTHER = "other"


class EvidenceType(Enum):
    """Classification of digital evidence artifacts."""
    NETWORK_CAPTURE = "network_capture"
    DISK_IMAGE = "disk_image"
    MEMORY_DUMP = "memory_dump"
    LOG_FILE = "log_file"
    MALWARE_SAMPLE = "malware_sample"
    EMAIL_ARTIFACT = "email_artifact"
    SCREENSHOT = "screenshot"
    CONFIGURATION = "configuration"
    USER_ACCOUNT_DATA = "user_account_data"
    DATABASE_EXPORT = "database_export"
    REGISTRY_EXPORT = "registry_export"
    PROCESS_LIST = "process_list"
    FILE_HASH = "file_hash"
    NETWORK_FLOW = "network_flow"
    FIREWALL_LOG = "firewall_log"
    IDS_ALERT = "ids_alert"
    AUTHENTICATION_LOG = "authentication_log"
    OTHER = "other"


class ActionType(Enum):
    """Types of incident response actions."""
    DETECTION = "detection"
    TRIAGE = "triage"
    CONTAINMENT = "containment"
    ERADICATION = "eradication"
    RECOVERY = "recovery"
    NOTIFICATION = "notification"
    ESCALATION = "escalation"
    EVIDENCE_COLLECTION = "evidence_collection"
    COMMUNICATION = "communication"
    DOCUMENTATION = "documentation"


class ActionPriority(Enum):
    """Priority classification for response actions."""
    IMMEDIATE = "immediate"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    DEFERRED = "deferred"


@dataclass
class Alert:
    """
    Represents a security alert that may trigger an incident.

    Alerts are generated by security tools (SIEM, IDS/IPS, EDR, etc.)
    and serve as the initial indicator of potential malicious activity.

    Attributes:
        alert_id: Unique identifier for this alert.
        source: Originating security tool or sensor.
        title: Brief description of the alert.
        description: Detailed alert information.
        severity: Alert severity level.
        timestamp: When the alert was generated.
        source_ip: Source IP address involved, if applicable.
        destination_ip: Destination IP address involved, if applicable.
        indicators: List of indicators of compromise (IOCs).
        raw_data: Original alert payload or log entry.
        false_positive: Whether this alert was classified as a false positive.
        correlated_alerts: IDs of related alerts grouped by correlation rules.
    """
    alert_id: str = field(default_factory=lambda: f"ALT-{uuid.uuid4().hex[:8].upper()}")
    source: str = ""
    title: str = ""
    description: str = ""
    severity: SeverityLevel = SeverityLevel.MEDIUM
    timestamp: datetime = field(default_factory=datetime.now)
    source_ip: Optional[str] = None
    destination_ip: Optional[str] = None
    indicators: List[str] = field(default_factory=list)
    raw_data: Optional[Dict[str, Any]] = None
    false_positive: bool = False
    correlated_alerts: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        """Serialize alert to dictionary for reporting."""
        return {
            "alert_id": self.alert_id,
            "source": self.source,
            "title": self.title,
            "description": self.description,
            "severity": self.severity.value,
            "timestamp": self.timestamp.isoformat(),
            "source_ip": self.source_ip,
            "destination_ip": self.destination_ip,
            "indicators": self.indicators,
            "false_positive": self.false_positive,
            "correlated_alerts": self.correlated_alerts,
        }


@dataclass
class Evidence:
    """
    Represents a piece of digital evidence collected during incident response.

    Maintains chain-of-custody metadata to ensure forensic integrity
    and admissibility. All evidence handling follows digital forensics
    best practices.

    Attributes:
        evidence_id: Unique evidence identifier.
        evidence_type: Classification of the evidence artifact.
        description: Description of the evidence item.
        collected_by: Name/ID of the analyst who collected the evidence.
        collected_at: Timestamp of evidence collection.
        source_system: System or host the evidence was collected from.
        file_path: Storage path of the evidence file.
        file_hash_md5: MD5 hash of the evidence file.
        file_hash_sha256: SHA-256 hash of the evidence file.
        file_size_bytes: Size of the evidence file in bytes.
        chain_of_custody: Ordered list of custody transfer records.
        tags: Descriptive tags for categorization.
        notes: Analyst notes about the evidence.
        is_volatile: Whether the evidence is volatile (e.g., memory, running processes).
        preservation_method: How the evidence was preserved.
        tool_used: Forensic tool used for collection.
        integrity_verified: Whether integrity was verified after collection.
    """
    evidence_id: str = field(default_factory=lambda: f"EV-{uuid.uuid4().hex[:8].upper()}")
    evidence_type: EvidenceType = EvidenceType.OTHER
    description: str = ""
    collected_by: str = ""
    collected_at: datetime = field(default_factory=datetime.now)
    source_system: str = ""
    file_path: Optional[str] = None
    file_hash_md5: Optional[str] = None
    file_hash_sha256: Optional[str] = None
    file_size_bytes: Optional[int] = None
    chain_of_custody: List[Dict[str, str]] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)
    notes: str = ""
    is_volatile: bool = False
    preservation_method: str = ""
    tool_used: str = ""
    integrity_verified: bool = False

    def add_custody_transfer(self, from_person: str, to_person: str, reason: str) -> None:
        """Record a chain-of-custody transfer event."""
        self.chain_of_custody.append({
            "timestamp": datetime.now().isoformat(),
            "from": from_person,
            "to": to_person,
            "reason": reason,
        })

    def to_dict(self) -> Dict[str, Any]:
        """Serialize evidence to dictionary for reporting."""
        return {
            "evidence_id": self.evidence_id,
            "evidence_type": self.evidence_type.value,
            "description": self.description,
            "collected_by": self.collected_by,
            "collected_at": self.collected_at.isoformat(),
            "source_system": self.source_system,
            "file_path": self.file_path,
            "file_hash_md5": self.file_hash_md5,
            "file_hash_sha256": self.file_hash_sha256,
            "file_size_bytes": self.file_size_bytes,
            "chain_of_custody": self.chain_of_custody,
            "tags": self.tags,
            "notes": self.notes,
            "is_volatile": self.is_volatile,
            "preservation_method": self.preservation_method,
            "tool_used": self.tool_used,
            "integrity_verified": self.integrity_verified,
        }


@dataclass
class TimelineEvent:
    """
    Represents a single event in the incident timeline.

    Timeline events document the chronological progression of an incident,
    from initial detection through resolution. Each event captures what
    happened, when, and who was involved.

    Attributes:
        event_id: Unique identifier for this timeline event.
        timestamp: When the event occurred.
        event_type: Category of the event (detection, action, communication, etc.).
        description: Detailed description of what occurred.
        actor: Person or system that performed or detected the event.
        source: System or tool that generated the event.
        details: Additional structured data about the event.
        is_automated: Whether the event was triggered by automated systems.
        phase: NIST IR phase during which this event occurred.
    """
    event_id: str = field(default_factory=lambda: f"EVT-{uuid.uuid4().hex[:8].upper()}")
    timestamp: datetime = field(default_factory=datetime.now)
    event_type: str = ""
    description: str = ""
    actor: str = ""
    source: str = ""
    details: Optional[Dict[str, Any]] = None
    is_automated: bool = False
    phase: str = "detection"

    def to_dict(self) -> Dict[str, Any]:
        """Serialize timeline event to dictionary."""
        return {
            "event_id": self.event_id,
            "timestamp": self.timestamp.isoformat(),
            "event_type": self.event_type,
            "description": self.description,
            "actor": self.actor,
            "source": self.source,
            "details": self.details,
            "is_automated": self.is_automated,
            "phase": self.phase,
        }


@dataclass
class Action:
    """
    Represents a response action taken during incident handling.

    Actions are the concrete steps performed by the IR team during
    each phase of the response lifecycle. They are tracked for
    documentation, scoring, and post-incident review.

    Attributes:
        action_id: Unique action identifier.
        action_type: Classification of the response action.
        priority: Urgency level of the action.
        title: Short description of the action.
        description: Detailed description of what needs to be done.
        assigned_to: Team member responsible for execution.
        status: Current status of the action.
        started_at: When execution of this action began.
        completed_at: When this action was completed.
        outcome: Result or finding from this action.
        dependencies: Action IDs that must be completed first.
        playbook_step: Reference to the playbook step this action implements.
        effectiveness_score: Post-action effectiveness rating (0.0 - 1.0).
        time_to_execute_minutes: Actual time taken to execute.
    """
    action_id: str = field(default_factory=lambda: f"ACT-{uuid.uuid4().hex[:8].upper()}")
    action_type: ActionType = ActionType.DETECTION
    priority: ActionPriority = ActionPriority.MEDIUM
    title: str = ""
    description: str = ""
    assigned_to: str = ""
    status: str = "pending"
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    outcome: str = ""
    dependencies: List[str] = field(default_factory=list)
    playbook_step: Optional[str] = None
    effectiveness_score: Optional[float] = None
    time_to_execute_minutes: Optional[int] = None

    def start(self) -> None:
        """Mark action as in-progress."""
        self.status = "in_progress"
        self.started_at = datetime.now()

    def complete(self, outcome: str, effectiveness: float = 1.0) -> None:
        """Mark action as completed with outcome and effectiveness rating."""
        self.status = "completed"
        self.completed_at = datetime.now()
        self.outcome = outcome
        self.effectiveness_score = max(0.0, min(1.0, effectiveness))
        if self.started_at:
            delta = self.completed_at - self.started_at
            self.time_to_execute_minutes = int(delta.total_seconds() / 60)

    def to_dict(self) -> Dict[str, Any]:
        """Serialize action to dictionary for reporting."""
        return {
            "action_id": self.action_id,
            "action_type": self.action_type.value,
            "priority": self.priority.value,
            "title": self.title,
            "description": self.description,
            "assigned_to": self.assigned_to,
            "status": self.status,
            "started_at": self.started_at.isoformat() if self.started_at else None,
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
            "outcome": self.outcome,
            "dependencies": self.dependencies,
            "playbook_step": self.playbook_step,
            "effectiveness_score": self.effectiveness_score,
            "time_to_execute_minutes": self.time_to_execute_minutes,
        }


@dataclass
class Incident:
    """
    Master incident record aggregating all response data.

    This is the top-level container for an incident, holding references
    to all alerts, evidence, timeline events, and actions associated
    with the response effort.

    Attributes:
        incident_id: Unique incident tracking number.
        title: Brief incident title.
        description: Detailed incident description.
        category: Incident classification category.
        severity: Current severity assessment.
        status: Current incident lifecycle status.
        created_at: When the incident record was created.
        updated_at: Last modification timestamp.
        closed_at: When the incident was closed.
        detected_at: When the incident was first detected.
        reported_by: Person or system that reported the incident.
        incident_commander: Lead responder coordinating the response.
        affected_systems: List of impacted systems/hosts.
        affected_users: Estimated number of affected users.
        alerts: Associated security alerts.
        evidence: Collected evidence items.
        timeline: Chronological event timeline.
        actions: Response actions taken.
        iocs: Indicators of compromise identified.
        attack_vector: Initial access or attack method.
        containment_strategy: Summary of containment approach.
        root_cause: Identified root cause of the incident.
        lessons_learned: Post-incident findings and recommendations.
        regulatory_notifications: Required regulatory notifications.
        business_impact_score: Calculated business impact (0.0 - 10.0).
        simulation_score: Score achieved during simulation (0 - 100).
    """
    incident_id: str = field(default_factory=lambda: f"INC-{datetime.now().strftime('%Y%m%d')}-{uuid.uuid4().hex[:6].upper()}")
    title: str = ""
    description: str = ""
    category: IncidentCategory = IncidentCategory.OTHER
    severity: SeverityLevel = SeverityLevel.MEDIUM
    status: IncidentStatus = IncidentStatus.NEW
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    closed_at: Optional[datetime] = None
    detected_at: Optional[datetime] = None
    reported_by: str = ""
    incident_commander: str = ""
    affected_systems: List[str] = field(default_factory=list)
    affected_users: int = 0
    alerts: List[Alert] = field(default_factory=list)
    evidence: List[Evidence] = field(default_factory=list)
    timeline: List[TimelineEvent] = field(default_factory=list)
    actions: List[Action] = field(default_factory=list)
    iocs: List[Dict[str, str]] = field(default_factory=list)
    attack_vector: str = ""
    containment_strategy: str = ""
    root_cause: str = ""
    lessons_learned: List[str] = field(default_factory=list)
    regulatory_notifications: List[str] = field(default_factory=list)
    business_impact_score: float = 0.0
    simulation_score: int = 0

    def escalate_severity(self, new_severity: SeverityLevel, reason: str) -> None:
        """Escalate or adjust incident severity with documentation."""
        old_severity = self.severity
        self.severity = new_severity
        self.updated_at = datetime.now()
        self.timeline.append(TimelineEvent(
            event_type="severity_change",
            description=f"Severity changed from {old_severity.value} to {new_severity.value}: {reason}",
            actor="system",
            phase="triage",
        ))

    def advance_status(self, new_status: IncidentStatus) -> None:
        """Transition incident to the next lifecycle phase."""
        old_status = self.status
        self.status = new_status
        self.updated_at = datetime.now()
        if new_status == IncidentStatus.CLOSED:
            self.closed_at = datetime.now()
        self.timeline.append(TimelineEvent(
            event_type="status_change",
            description=f"Incident status changed from {old_status.value} to {new_status.value}",
            actor="system",
            phase=new_status.value,
        ))

    def add_ioc(self, ioc_type: str, value: str, confidence: str = "high") -> None:
        """Record an indicator of compromise."""
        self.iocs.append({
            "type": ioc_type,
            "value": value,
            "confidence": confidence,
            "discovered_at": datetime.now().isoformat(),
        })

    def get_duration_hours(self) -> Optional[float]:
        """Calculate incident duration in hours."""
        end = self.closed_at or datetime.now()
        if self.detected_at:
            delta = end - self.detected_at
            return round(delta.total_seconds() / 3600, 2)
        return None

    def to_dict(self) -> Dict[str, Any]:
        """Serialize full incident record to dictionary."""
        return {
            "incident_id": self.incident_id,
            "title": self.title,
            "description": self.description,
            "category": self.category.value,
            "severity": self.severity.value,
            "status": self.status.value,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
            "closed_at": self.closed_at.isoformat() if self.closed_at else None,
            "detected_at": self.detected_at.isoformat() if self.detected_at else None,
            "reported_by": self.reported_by,
            "incident_commander": self.incident_commander,
            "affected_systems": self.affected_systems,
            "affected_users": self.affected_users,
            "alerts": [a.to_dict() for a in self.alerts],
            "evidence": [e.to_dict() for e in self.evidence],
            "timeline": [t.to_dict() for t in self.timeline],
            "actions": [a.to_dict() for a in self.actions],
            "iocs": self.iocs,
            "attack_vector": self.attack_vector,
            "containment_strategy": self.containment_strategy,
            "root_cause": self.root_cause,
            "lessons_learned": self.lessons_learned,
            "regulatory_notifications": self.regulatory_notifications,
            "business_impact_score": self.business_impact_score,
            "simulation_score": self.simulation_score,
            "duration_hours": self.get_duration_hours(),
        }
