"""
Utility functions for the Crypto Wallet Explorer.

Provides hex encoding/decoding, checksum address validation, unit conversions
between wei/gwei/ether, and other shared helpers used across the project.

WARNING: EDUCATIONAL USE ONLY -- TESTNET ONLY.
Never use wallets or keys generated by this tool for real cryptocurrency.
"""

import re
from decimal import Decimal, InvalidOperation
from typing import Union


# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

WEI_PER_GWEI = 10**9
WEI_PER_ETHER = 10**18
GWEI_PER_ETHER = 10**9

# EIP-55 mixed-case checksum address pattern
ADDRESS_PATTERN = re.compile(r"^0x[0-9a-fA-F]{40}$")

# Sepolia chain ID
SEPOLIA_CHAIN_ID = 11155111

# Standard ERC-20 ABI fragment for balanceOf and decimals
ERC20_BALANCE_ABI = [
    {
        "constant": True,
        "inputs": [{"name": "_owner", "type": "address"}],
        "name": "balanceOf",
        "outputs": [{"name": "balance", "type": "uint256"}],
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "decimals",
        "outputs": [{"name": "", "type": "uint8"}],
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "symbol",
        "outputs": [{"name": "", "type": "string"}],
        "type": "function",
    },
    {
        "constant": True,
        "inputs": [],
        "name": "name",
        "outputs": [{"name": "", "type": "string"}],
        "type": "function",
    },
]


# ---------------------------------------------------------------------------
# Hex encoding / decoding
# ---------------------------------------------------------------------------

def bytes_to_hex(data: bytes, prefix: bool = True) -> str:
    """
    Convert bytes to a hexadecimal string.

    Parameters
    ----------
    data : bytes
        The raw bytes to encode.
    prefix : bool
        If True (default), prepend '0x' to the result.

    Returns
    -------
    str
        The hex-encoded string.

    Examples
    --------
    >>> bytes_to_hex(b'\\xde\\xad\\xbe\\xef')
    '0xdeadbeef'
    >>> bytes_to_hex(b'\\xde\\xad\\xbe\\xef', prefix=False)
    'deadbeef'
    """
    hex_str = data.hex()
    return f"0x{hex_str}" if prefix else hex_str


def hex_to_bytes(hex_string: str) -> bytes:
    """
    Convert a hexadecimal string to bytes.

    Parameters
    ----------
    hex_string : str
        The hex string, with or without '0x' prefix.

    Returns
    -------
    bytes
        The decoded bytes.

    Raises
    ------
    ValueError
        If the string is not valid hexadecimal.

    Examples
    --------
    >>> hex_to_bytes('0xdeadbeef')
    b'\\xde\\xad\\xbe\\xef'
    >>> hex_to_bytes('deadbeef')
    b'\\xde\\xad\\xbe\\xef'
    """
    clean = hex_string.lower().strip()
    if clean.startswith("0x"):
        clean = clean[2:]
    if len(clean) % 2 != 0:
        clean = "0" + clean
    return bytes.fromhex(clean)


def is_valid_hex(value: str) -> bool:
    """
    Check if a string is valid hexadecimal (with or without 0x prefix).

    Parameters
    ----------
    value : str
        The string to validate.

    Returns
    -------
    bool
        True if the string represents valid hex data.
    """
    clean = value.strip().lower()
    if clean.startswith("0x"):
        clean = clean[2:]
    try:
        int(clean, 16)
        return len(clean) > 0
    except ValueError:
        return False


# ---------------------------------------------------------------------------
# Address validation
# ---------------------------------------------------------------------------

def is_valid_address(address: str) -> bool:
    """
    Check if a string is a valid Ethereum address (40 hex chars with 0x prefix).

    This checks format only, not EIP-55 checksum. Use ``is_checksum_address``
    for full checksum validation.

    Parameters
    ----------
    address : str
        The address to validate.

    Returns
    -------
    bool
        True if the address has valid format.

    Examples
    --------
    >>> is_valid_address('0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045')
    True
    >>> is_valid_address('not-an-address')
    False
    """
    return bool(ADDRESS_PATTERN.match(address))


def is_checksum_address(address: str) -> bool:
    """
    Validate an Ethereum address against the EIP-55 mixed-case checksum.

    EIP-55 encoding uses the Keccak-256 hash of the lowercase address to
    determine which characters should be uppercase. This provides a built-in
    error detection mechanism.

    Parameters
    ----------
    address : str
        The address to validate (must include 0x prefix).

    Returns
    -------
    bool
        True if the address passes EIP-55 checksum validation.
    """
    if not is_valid_address(address):
        return False

    try:
        from eth_utils import is_checksum_address as _eth_checksum
        return _eth_checksum(address)
    except ImportError:
        # Fallback: manual EIP-55 check using hashlib keccak
        try:
            from Crypto.Hash import keccak
            addr_lower = address[2:].lower()
            k = keccak.new(digest_bits=256)
            k.update(addr_lower.encode("ascii"))
            hash_hex = k.hexdigest()
        except ImportError:
            import hashlib
            addr_lower = address[2:].lower()
            hash_hex = hashlib.sha3_256(addr_lower.encode("ascii")).hexdigest()

        for i, char in enumerate(addr_lower):
            if char in "0123456789":
                continue
            if int(hash_hex[i], 16) >= 8:
                if address[2 + i] != char.upper():
                    return False
            else:
                if address[2 + i] != char.lower():
                    return False
        return True


def to_checksum_address(address: str) -> str:
    """
    Convert an Ethereum address to EIP-55 checksum format.

    Parameters
    ----------
    address : str
        The address to convert (with 0x prefix).

    Returns
    -------
    str
        The checksummed address.

    Raises
    ------
    ValueError
        If the input is not a valid address format.
    """
    if not is_valid_address(address):
        raise ValueError(f"Invalid Ethereum address format: {address}")

    try:
        from eth_utils import to_checksum_address as _eth_checksum
        return _eth_checksum(address)
    except ImportError:
        from web3 import Web3
        return Web3.to_checksum_address(address)


# ---------------------------------------------------------------------------
# Unit conversions (wei / gwei / ether)
# ---------------------------------------------------------------------------

def wei_to_ether(wei: Union[int, str]) -> Decimal:
    """
    Convert wei to ether.

    Parameters
    ----------
    wei : int or str
        Amount in wei.

    Returns
    -------
    Decimal
        Amount in ether.

    Examples
    --------
    >>> wei_to_ether(1000000000000000000)
    Decimal('1')
    >>> wei_to_ether('500000000000000000')
    Decimal('0.5')
    """
    return Decimal(str(wei)) / Decimal(str(WEI_PER_ETHER))


def ether_to_wei(ether: Union[float, str, Decimal]) -> int:
    """
    Convert ether to wei.

    Parameters
    ----------
    ether : float, str, or Decimal
        Amount in ether.

    Returns
    -------
    int
        Amount in wei.

    Examples
    --------
    >>> ether_to_wei(1.0)
    1000000000000000000
    >>> ether_to_wei('0.5')
    500000000000000000
    """
    return int(Decimal(str(ether)) * Decimal(str(WEI_PER_ETHER)))


def wei_to_gwei(wei: Union[int, str]) -> Decimal:
    """
    Convert wei to gwei.

    Parameters
    ----------
    wei : int or str
        Amount in wei.

    Returns
    -------
    Decimal
        Amount in gwei.

    Examples
    --------
    >>> wei_to_gwei(1000000000)
    Decimal('1')
    """
    return Decimal(str(wei)) / Decimal(str(WEI_PER_GWEI))


def gwei_to_wei(gwei: Union[float, str, Decimal]) -> int:
    """
    Convert gwei to wei.

    Parameters
    ----------
    gwei : float, str, or Decimal
        Amount in gwei.

    Returns
    -------
    int
        Amount in wei.

    Examples
    --------
    >>> gwei_to_wei(1.0)
    1000000000
    """
    return int(Decimal(str(gwei)) * Decimal(str(WEI_PER_GWEI)))


def ether_to_gwei(ether: Union[float, str, Decimal]) -> Decimal:
    """
    Convert ether to gwei.

    Parameters
    ----------
    ether : float, str, or Decimal
        Amount in ether.

    Returns
    -------
    Decimal
        Amount in gwei.
    """
    return Decimal(str(ether)) * Decimal(str(GWEI_PER_ETHER))


def format_wei(wei: Union[int, str], unit: str = "ether") -> str:
    """
    Format a wei amount as a human-readable string in the specified unit.

    Parameters
    ----------
    wei : int or str
        Amount in wei.
    unit : str
        Target unit: 'wei', 'gwei', or 'ether'.

    Returns
    -------
    str
        Formatted string with unit label.

    Examples
    --------
    >>> format_wei(1000000000000000000, 'ether')
    '1 ETH'
    >>> format_wei(20000000000, 'gwei')
    '20 Gwei'
    """
    unit = unit.lower()
    if unit == "wei":
        return f"{int(wei)} Wei"
    elif unit == "gwei":
        gwei_val = wei_to_gwei(wei)
        return f"{gwei_val:f} Gwei".rstrip("0").rstrip(".")  + " Gwei" if "Gwei" not in f"{gwei_val}" else f"{gwei_val:f} Gwei"
    elif unit == "ether":
        ether_val = wei_to_ether(wei)
        # Remove trailing zeros but keep at least one decimal place
        formatted = f"{ether_val:.18f}".rstrip("0").rstrip(".")
        return f"{formatted} ETH"
    else:
        raise ValueError(f"Unknown unit: {unit}. Use 'wei', 'gwei', or 'ether'.")


# ---------------------------------------------------------------------------
# Miscellaneous helpers
# ---------------------------------------------------------------------------

def truncate_hash(hash_str: str, front: int = 6, back: int = 4) -> str:
    """
    Truncate a hex hash for display purposes.

    Parameters
    ----------
    hash_str : str
        The full hash string (e.g., '0xabc123...def456').
    front : int
        Number of characters to keep at the front (after 0x).
    back : int
        Number of characters to keep at the end.

    Returns
    -------
    str
        Truncated hash like '0xabc123...def456'.

    Examples
    --------
    >>> truncate_hash('0x1234567890abcdef1234567890abcdef12345678')
    '0x123456...5678'
    """
    if len(hash_str) <= front + back + 4:
        return hash_str
    prefix = hash_str[:2] if hash_str.startswith("0x") else ""
    body = hash_str[2:] if hash_str.startswith("0x") else hash_str
    return f"{prefix}{body[:front]}...{body[-back:]}"


def validate_private_key(key: str) -> bool:
    """
    Validate that a string looks like a valid private key (32 bytes hex).

    Parameters
    ----------
    key : str
        The private key string to validate.

    Returns
    -------
    bool
        True if it's 32 bytes of valid hex.
    """
    clean = key.strip().lower()
    if clean.startswith("0x"):
        clean = clean[2:]
    return len(clean) == 64 and all(c in "0123456789abcdef" for c in clean)


def print_security_warning():
    """Print a prominent security warning to stderr."""
    import sys
    warning = (
        "\n"
        "+" + "-" * 68 + "+\n"
        "|  SECURITY WARNING: EDUCATIONAL / TESTNET USE ONLY                  |\n"
        "|                                                                    |\n"
        "|  - NEVER use these keys/wallets for real cryptocurrency            |\n"
        "|  - All generated material is INSECURE and potentially PUBLIC       |\n"
        "|  - Use hardware wallets or audited software for real funds         |\n"
        "|  - This tool is for learning blockchain concepts only              |\n"
        "+" + "-" * 68 + "+\n"
    )
    print(warning, file=sys.stderr)
