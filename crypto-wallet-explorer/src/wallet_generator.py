"""
Wallet Generator Module
=======================

Generates cryptocurrency wallets using industry-standard BIP-39 mnemonics,
BIP-32 hierarchical deterministic key derivation, and BIP-44 path conventions.
Computes Ethereum addresses from derived keys.

WARNING: EDUCATIONAL USE ONLY -- TESTNET ONLY.
==============================================
NEVER use any wallet, mnemonic, or private key generated by this module
to store, send, or receive real cryptocurrency. All generated keys should
be treated as publicly compromised. Any real funds sent to these addresses
WILL BE LOST OR STOLEN.

Use established, audited wallet software (hardware wallets, MetaMask, etc.)
for managing real cryptocurrency.

Standards Implemented
---------------------
- BIP-39: Mnemonic code for generating deterministic keys
  https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
- BIP-32: Hierarchical Deterministic Wallets
  https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
- BIP-44: Multi-Account Hierarchy for Deterministic Wallets
  https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
"""

import hashlib
import hmac
import os
import struct
from dataclasses import dataclass, field
from typing import List, Optional, Tuple

from mnemonic import Mnemonic
from eth_account import Account

from .utils import bytes_to_hex, print_security_warning


# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

# BIP-44 derivation path for Ethereum
DEFAULT_DERIVATION_PATH = "m/44'/60'/0'/0/0"

# Supported mnemonic strengths (bits of entropy -> number of words)
MNEMONIC_STRENGTHS = {
    128: 12,  # 12 words
    160: 15,  # 15 words
    192: 18,  # 18 words
    224: 21,  # 21 words
    256: 24,  # 24 words
}

# Hardened key derivation offset
HARDENED_OFFSET = 0x80000000

# HMAC key for master key derivation (as per BIP-32 spec)
BIP32_SEED_KEY = b"Bitcoin seed"


# ---------------------------------------------------------------------------
# Data classes
# ---------------------------------------------------------------------------

@dataclass
class DerivedKey:
    """Represents a derived key at a specific point in the derivation path."""
    path: str
    private_key: bytes
    chain_code: bytes
    depth: int
    index: int
    is_hardened: bool

    @property
    def private_key_hex(self) -> str:
        """Return the private key as a hex string with 0x prefix."""
        return bytes_to_hex(self.private_key)

    @property
    def chain_code_hex(self) -> str:
        """Return the chain code as a hex string with 0x prefix."""
        return bytes_to_hex(self.chain_code)


@dataclass
class WalletInfo:
    """
    Complete wallet information generated from a mnemonic.

    WARNING: This is for educational/testnet use only. Never use these
    keys for real funds.
    """
    mnemonic: str
    passphrase: str
    seed: bytes
    master_private_key: bytes
    master_chain_code: bytes
    derivation_path: str
    derived_keys: List[DerivedKey]
    final_private_key: bytes
    ethereum_address: str
    word_count: int

    @property
    def seed_hex(self) -> str:
        """Return the seed as a hex string."""
        return bytes_to_hex(self.seed)

    @property
    def master_private_key_hex(self) -> str:
        """Return the master private key as a hex string."""
        return bytes_to_hex(self.master_private_key)

    @property
    def final_private_key_hex(self) -> str:
        """Return the final derived private key as a hex string."""
        return bytes_to_hex(self.final_private_key)

    def summary(self) -> dict:
        """Return a summary dict (masking sensitive data for display)."""
        words = self.mnemonic.split()
        masked_mnemonic = " ".join(
            [words[0], "...", f"({len(words)} words)", "...", words[-1]]
        )
        return {
            "mnemonic_preview": masked_mnemonic,
            "word_count": self.word_count,
            "derivation_path": self.derivation_path,
            "ethereum_address": self.ethereum_address,
            "derivation_depth": len(self.derived_keys),
        }


# ---------------------------------------------------------------------------
# BIP-39: Mnemonic Generation
# ---------------------------------------------------------------------------

def generate_mnemonic(strength: int = 128, language: str = "english") -> str:
    """
    Generate a BIP-39 mnemonic phrase.

    The mnemonic is generated from cryptographically secure random entropy.
    The entropy is encoded as a sequence of words from a standardized wordlist.

    Parameters
    ----------
    strength : int
        Bits of entropy. Must be one of: 128 (12 words), 160 (15 words),
        192 (18 words), 224 (21 words), 256 (24 words).
    language : str
        Language for the wordlist. Default is 'english'.

    Returns
    -------
    str
        A space-separated mnemonic phrase.

    Raises
    ------
    ValueError
        If strength is not a supported value.

    Examples
    --------
    >>> mnemonic = generate_mnemonic(128)
    >>> len(mnemonic.split())
    12
    """
    if strength not in MNEMONIC_STRENGTHS:
        raise ValueError(
            f"Strength must be one of {list(MNEMONIC_STRENGTHS.keys())}, "
            f"got {strength}"
        )

    mnemo = Mnemonic(language)
    return mnemo.generate(strength=strength)


def validate_mnemonic(mnemonic: str, language: str = "english") -> bool:
    """
    Validate a BIP-39 mnemonic phrase.

    Checks that:
    1. All words are in the BIP-39 wordlist
    2. The checksum embedded in the last word is correct
    3. The word count is valid (12, 15, 18, 21, or 24)

    Parameters
    ----------
    mnemonic : str
        The mnemonic phrase to validate.
    language : str
        Language of the wordlist.

    Returns
    -------
    bool
        True if the mnemonic is valid.
    """
    mnemo = Mnemonic(language)
    return mnemo.check(mnemonic)


# ---------------------------------------------------------------------------
# BIP-39: Seed Derivation
# ---------------------------------------------------------------------------

def mnemonic_to_seed(mnemonic: str, passphrase: str = "") -> bytes:
    """
    Convert a BIP-39 mnemonic to a 512-bit seed.

    Uses PBKDF2 with HMAC-SHA512 and 2048 iterations. The salt is
    "mnemonic" + passphrase (the passphrase provides additional security
    and can generate different wallets from the same mnemonic).

    Parameters
    ----------
    mnemonic : str
        The BIP-39 mnemonic phrase.
    passphrase : str
        Optional passphrase (also called the "25th word").

    Returns
    -------
    bytes
        512-bit (64-byte) seed.

    Notes
    -----
    The PBKDF2 parameters are:
    - PRF: HMAC-SHA512
    - Password: mnemonic phrase (UTF-8 NFKD normalized)
    - Salt: "mnemonic" + passphrase (UTF-8 NFKD normalized)
    - Iterations: 2048
    - Key length: 64 bytes (512 bits)
    """
    mnemo = Mnemonic("english")
    return mnemo.to_seed(mnemonic, passphrase)


# ---------------------------------------------------------------------------
# BIP-32: Master Key Derivation
# ---------------------------------------------------------------------------

def seed_to_master_key(seed: bytes) -> Tuple[bytes, bytes]:
    """
    Derive the master private key and chain code from a seed.

    As per BIP-32, the seed is passed through HMAC-SHA512 with the key
    "Bitcoin seed". The first 32 bytes become the master private key,
    and the last 32 bytes become the master chain code.

    Parameters
    ----------
    seed : bytes
        The 512-bit seed from BIP-39.

    Returns
    -------
    tuple of (bytes, bytes)
        (master_private_key, master_chain_code), each 32 bytes.

    Raises
    ------
    ValueError
        If the derived key is zero or >= the secp256k1 curve order.
    """
    I = hmac.new(BIP32_SEED_KEY, seed, hashlib.sha512).digest()
    master_key = I[:32]
    chain_code = I[32:]

    # Validate that the key is within the valid range for secp256k1
    key_int = int.from_bytes(master_key, "big")
    secp256k1_order = (
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
    )
    if key_int == 0 or key_int >= secp256k1_order:
        raise ValueError(
            "Derived master key is out of range. This is astronomically "
            "unlikely -- try a different seed."
        )

    return master_key, chain_code


# ---------------------------------------------------------------------------
# BIP-32: Child Key Derivation
# ---------------------------------------------------------------------------

def _derive_child_key(
    parent_key: bytes,
    parent_chain_code: bytes,
    index: int,
    hardened: bool = False,
) -> Tuple[bytes, bytes]:
    """
    Derive a child key from a parent key using BIP-32.

    For hardened derivation (index >= 2^31), the parent private key is used
    directly. For normal derivation, the parent public key is used.

    Parameters
    ----------
    parent_key : bytes
        Parent private key (32 bytes).
    parent_chain_code : bytes
        Parent chain code (32 bytes).
    index : int
        Child index (0-based). For hardened, this is the logical index
        (the HARDENED_OFFSET is added internally if hardened=True).
    hardened : bool
        If True, perform hardened derivation.

    Returns
    -------
    tuple of (bytes, bytes)
        (child_private_key, child_chain_code).
    """
    secp256k1_order = (
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
    )

    if hardened:
        # Hardened child: data = 0x00 || parent_key || index
        actual_index = index + HARDENED_OFFSET
        data = b"\x00" + parent_key + struct.pack(">I", actual_index)
    else:
        # Normal child: data = parent_public_key || index
        # We need to compute the compressed public key from the private key
        from eth_keys import keys
        pk = keys.PrivateKey(parent_key)
        public_key_bytes = pk.public_key.to_compressed_bytes()
        data = public_key_bytes + struct.pack(">I", index)

    I = hmac.new(parent_chain_code, data, hashlib.sha512).digest()
    IL = I[:32]
    IR = I[32:]

    # child_key = (IL + parent_key) mod n
    il_int = int.from_bytes(IL, "big")
    parent_int = int.from_bytes(parent_key, "big")
    child_int = (il_int + parent_int) % secp256k1_order

    if il_int >= secp256k1_order or child_int == 0:
        raise ValueError(
            "Derived child key is invalid. This is astronomically unlikely."
        )

    child_key = child_int.to_bytes(32, "big")
    child_chain_code = IR

    return child_key, child_chain_code


def parse_derivation_path(path: str) -> List[Tuple[int, bool]]:
    """
    Parse a BIP-44 derivation path string into (index, hardened) pairs.

    Parameters
    ----------
    path : str
        Derivation path like "m/44'/60'/0'/0/0".

    Returns
    -------
    list of (int, bool)
        Each element is (index, is_hardened).

    Raises
    ------
    ValueError
        If the path format is invalid.

    Examples
    --------
    >>> parse_derivation_path("m/44'/60'/0'/0/0")
    [(44, True), (60, True), (0, True), (0, False), (0, False)]
    """
    if not path.startswith("m/"):
        raise ValueError(f"Derivation path must start with 'm/', got: {path}")

    components = path[2:].split("/")
    result = []

    for component in components:
        if not component:
            raise ValueError(f"Empty component in derivation path: {path}")
        hardened = component.endswith("'") or component.endswith("H")
        index_str = component.rstrip("'H")
        try:
            index = int(index_str)
        except ValueError:
            raise ValueError(
                f"Invalid index '{index_str}' in derivation path: {path}"
            )
        if index < 0:
            raise ValueError(
                f"Negative index {index} in derivation path: {path}"
            )
        result.append((index, hardened))

    return result


# ---------------------------------------------------------------------------
# BIP-44: Full Derivation
# ---------------------------------------------------------------------------

def derive_key_from_path(
    master_key: bytes,
    master_chain_code: bytes,
    path: str = DEFAULT_DERIVATION_PATH,
) -> Tuple[bytes, List[DerivedKey]]:
    """
    Derive a key through a full BIP-44 derivation path.

    Walks the path from the master key, deriving each child key in sequence,
    and returns the final key along with all intermediate keys.

    Parameters
    ----------
    master_key : bytes
        The master private key (32 bytes).
    master_chain_code : bytes
        The master chain code (32 bytes).
    path : str
        The derivation path (default: "m/44'/60'/0'/0/0").

    Returns
    -------
    tuple of (bytes, list of DerivedKey)
        The final derived private key and a list of all intermediate keys.
    """
    path_components = parse_derivation_path(path)

    current_key = master_key
    current_chain_code = master_chain_code
    derived_keys = []
    current_path = "m"

    for depth, (index, hardened) in enumerate(path_components, start=1):
        suffix = f"{index}'" if hardened else str(index)
        current_path = f"{current_path}/{suffix}"

        current_key, current_chain_code = _derive_child_key(
            current_key, current_chain_code, index, hardened
        )

        derived_keys.append(
            DerivedKey(
                path=current_path,
                private_key=current_key,
                chain_code=current_chain_code,
                depth=depth,
                index=index,
                is_hardened=hardened,
            )
        )

    return current_key, derived_keys


# ---------------------------------------------------------------------------
# Ethereum Address Computation
# ---------------------------------------------------------------------------

def private_key_to_address(private_key: bytes) -> str:
    """
    Compute an Ethereum address from a private key.

    The process:
    1. Compute the uncompressed public key (64 bytes) from the private key
       using the secp256k1 elliptic curve
    2. Hash the public key with Keccak-256
    3. Take the last 20 bytes of the hash as the address
    4. Apply EIP-55 mixed-case checksum encoding

    Parameters
    ----------
    private_key : bytes
        The 32-byte private key.

    Returns
    -------
    str
        The Ethereum address with EIP-55 checksum (0x-prefixed).
    """
    account = Account.from_key(private_key)
    return account.address


def private_key_to_public_key(private_key: bytes) -> bytes:
    """
    Compute the uncompressed public key from a private key.

    Parameters
    ----------
    private_key : bytes
        The 32-byte private key.

    Returns
    -------
    bytes
        The 64-byte uncompressed public key (without the 0x04 prefix).
    """
    from eth_keys import keys
    pk = keys.PrivateKey(private_key)
    return pk.public_key.to_bytes()


# ---------------------------------------------------------------------------
# High-Level Wallet Generation
# ---------------------------------------------------------------------------

def generate_wallet(
    strength: int = 128,
    passphrase: str = "",
    derivation_path: str = DEFAULT_DERIVATION_PATH,
    language: str = "english",
) -> WalletInfo:
    """
    Generate a complete Ethereum wallet from scratch.

    This is the main entry point for wallet generation. It performs the
    complete pipeline:

    1. Generate a BIP-39 mnemonic
    2. Derive a 512-bit seed
    3. Derive the master key (BIP-32)
    4. Walk the derivation path (BIP-44)
    5. Compute the Ethereum address

    Parameters
    ----------
    strength : int
        Entropy bits for mnemonic generation (128=12 words, 256=24 words).
    passphrase : str
        Optional passphrase for seed derivation.
    derivation_path : str
        BIP-44 path (default: "m/44'/60'/0'/0/0").
    language : str
        Mnemonic wordlist language.

    Returns
    -------
    WalletInfo
        Complete wallet information including all intermediate keys.

    .. warning::
        EDUCATIONAL USE ONLY. Never use this wallet for real cryptocurrency.
        Generated keys are not securely stored and should be considered
        publicly compromised.
    """
    print_security_warning()

    # Step 1: Generate mnemonic
    mnemonic = generate_mnemonic(strength, language)

    # Step 2: Derive seed
    seed = mnemonic_to_seed(mnemonic, passphrase)

    # Step 3: Derive master key
    master_key, master_chain_code = seed_to_master_key(seed)

    # Step 4: Derive through path
    final_key, derived_keys = derive_key_from_path(
        master_key, master_chain_code, derivation_path
    )

    # Step 5: Compute Ethereum address
    address = private_key_to_address(final_key)

    return WalletInfo(
        mnemonic=mnemonic,
        passphrase=passphrase,
        seed=seed,
        master_private_key=master_key,
        master_chain_code=master_chain_code,
        derivation_path=derivation_path,
        derived_keys=derived_keys,
        final_private_key=final_key,
        ethereum_address=address,
        word_count=len(mnemonic.split()),
    )


def restore_wallet(
    mnemonic: str,
    passphrase: str = "",
    derivation_path: str = DEFAULT_DERIVATION_PATH,
) -> WalletInfo:
    """
    Restore a wallet from an existing mnemonic phrase.

    Parameters
    ----------
    mnemonic : str
        The BIP-39 mnemonic phrase.
    passphrase : str
        Optional passphrase used during original wallet creation.
    derivation_path : str
        BIP-44 derivation path.

    Returns
    -------
    WalletInfo
        The restored wallet information.

    Raises
    ------
    ValueError
        If the mnemonic is invalid.

    .. warning::
        EDUCATIONAL USE ONLY. Do not enter real mnemonics into this tool.
        Doing so may compromise your real funds.
    """
    print_security_warning()

    if not validate_mnemonic(mnemonic):
        raise ValueError(
            "Invalid mnemonic phrase. Check spelling and word count "
            "(must be 12, 15, 18, 21, or 24 words from the BIP-39 wordlist)."
        )

    seed = mnemonic_to_seed(mnemonic, passphrase)
    master_key, master_chain_code = seed_to_master_key(seed)
    final_key, derived_keys = derive_key_from_path(
        master_key, master_chain_code, derivation_path
    )
    address = private_key_to_address(final_key)

    return WalletInfo(
        mnemonic=mnemonic,
        passphrase=passphrase,
        seed=seed,
        master_private_key=master_key,
        master_chain_code=master_chain_code,
        derivation_path=derivation_path,
        derived_keys=derived_keys,
        final_private_key=final_key,
        ethereum_address=address,
        word_count=len(mnemonic.split()),
    )


def derive_multiple_addresses(
    mnemonic: str,
    passphrase: str = "",
    count: int = 5,
    account: int = 0,
) -> List[Tuple[str, str, str]]:
    """
    Derive multiple Ethereum addresses from a single mnemonic.

    Increments the address_index in the BIP-44 path to generate
    sequential addresses from the same account.

    Parameters
    ----------
    mnemonic : str
        The BIP-39 mnemonic phrase.
    passphrase : str
        Optional passphrase.
    count : int
        Number of addresses to derive.
    account : int
        The account index in the BIP-44 path.

    Returns
    -------
    list of (str, str, str)
        List of (path, address, private_key_hex) tuples.
    """
    seed = mnemonic_to_seed(mnemonic, passphrase)
    master_key, master_chain_code = seed_to_master_key(seed)

    addresses = []
    for i in range(count):
        path = f"m/44'/60'/{account}'/0/{i}"
        final_key, _ = derive_key_from_path(master_key, master_chain_code, path)
        address = private_key_to_address(final_key)
        addresses.append((path, address, bytes_to_hex(final_key)))

    return addresses
