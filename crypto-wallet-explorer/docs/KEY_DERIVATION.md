# Key Derivation Explained: BIP-39, BIP-32, and BIP-44

> **WARNING**: This document accompanies an educational tool.
> NEVER use wallets generated by the Crypto Wallet Explorer for real funds.
> All keys discussed here should be treated as publicly compromised examples.

---

## Table of Contents

1. [Overview](#overview)
2. [BIP-39: Mnemonic Phrases](#bip-39-mnemonic-phrases)
3. [BIP-32: Hierarchical Deterministic Wallets](#bip-32-hierarchical-deterministic-wallets)
4. [BIP-44: Multi-Account Hierarchy](#bip-44-multi-account-hierarchy)
5. [Ethereum-Specific Derivation](#ethereum-specific-derivation)
6. [Complete Flow Diagram](#complete-flow-diagram)
7. [Security Implications](#security-implications)

---

## Overview

Modern cryptocurrency wallets use a layered system of standards to generate
and manage keys. The three key standards are:

```
+------------------+     +------------------+     +------------------+
|     BIP-39       |     |     BIP-32       |     |     BIP-44       |
|                  |     |                  |     |                  |
| Mnemonic phrase  |---->| HD key tree      |---->| Standard paths   |
| generation and   |     | derivation from  |     | for multi-coin,  |
| seed derivation  |     | a master key     |     | multi-account    |
+------------------+     +------------------+     +------------------+
```

Together, they allow a single mnemonic phrase to generate millions of
unique addresses across multiple cryptocurrencies and accounts.

---

## BIP-39: Mnemonic Phrases

**BIP-39** (Bitcoin Improvement Proposal 39) defines how to encode
cryptographic entropy as a human-readable sequence of words.

### Step 1: Entropy Generation

```
Random entropy (128 bits for 12 words):
  10101100 00010111 01011010 11001110
  11100010 01010010 00001111 10111100
  01001110 11010001 10100011 01011110
  10010010 00110100 10001101 01110001
```

The entropy MUST come from a cryptographically secure random number
generator (CSPRNG). Weak randomness is the most catastrophic failure
mode -- it makes all derived keys predictable.

### Step 2: Checksum

A checksum is appended to detect errors:

```
Entropy:   128 bits
Checksum:  SHA-256(entropy)[0:4]  =  4 bits
Total:     132 bits
```

The checksum length is: entropy_bits / 32

| Entropy (bits) | Checksum (bits) | Total (bits) | Words |
|---------------:|----------------:|-------------:|------:|
| 128            | 4               | 132          | 12    |
| 160            | 5               | 165          | 15    |
| 192            | 6               | 198          | 18    |
| 224            | 7               | 231          | 21    |
| 256            | 8               | 264          | 24    |

### Step 3: Word Encoding

The total bits are split into 11-bit groups, each mapping to a word
from the BIP-39 wordlist (2048 words, since 2^11 = 2048):

```
132 bits (for 12 words):

  10101100001  01011101011  01011001110
  word 1       word 2       word 3
  (index 1377) (index 747)  (index 718)

  11100010010  10010000011  11101111000
  word 4       word 5       word 6

  10011101101  00011010001  10100011010
  word 7       word 8       word 9

  11110100100  10001101001  00011010111 <- last bits include checksum
  word 10      word 11      word 12
```

### Step 4: Seed Derivation (PBKDF2)

The mnemonic phrase is converted to a 512-bit binary seed using
PBKDF2-HMAC-SHA512:

```
+--------------------------------------------------+
|  PBKDF2-HMAC-SHA512                              |
|                                                  |
|  Password: mnemonic phrase (UTF-8 NFKD)         |
|  Salt:     "mnemonic" + passphrase (UTF-8 NFKD) |
|  Iterations: 2048                                |
|  Key Length: 64 bytes (512 bits)                 |
|                                                  |
|  Output: Binary Seed                             |
+--------------------------------------------------+

Mnemonic: "abandon abandon ... about"
                    |
                    v
            +---------------+
            |   PBKDF2      |
            | HMAC-SHA512   |<---- Salt: "mnemonic" + ""
            | 2048 rounds   |
            +---------------+
                    |
                    v
        512-bit Binary Seed
        5eb00bbddcf069084889a8ab9155568165f5...
```

The passphrase (sometimes called the "25th word") provides an extra
layer of security. The same mnemonic with a different passphrase
produces an entirely different seed and wallet.

---

## BIP-32: Hierarchical Deterministic Wallets

**BIP-32** defines how to derive a tree of key pairs from a single
master key. This enables generating millions of keys from one seed.

### Master Key Derivation

```
512-bit Seed
    |
    v
+-----------------------------------+
| HMAC-SHA512                       |
| Key: "Bitcoin seed" (ASCII)       |
| Data: seed (512 bits)             |
+-----------------------------------+
    |
    v
+-----------------------------------+
| 512-bit output                    |
|                                   |
| [  Left 256 bits  |  Right 256  ] |
| [  Master Private |  Master      ] |
| [  Key            |  Chain Code  ] |
+-----------------------------------+
```

The **chain code** is used in child key derivation to add entropy
at each level, preventing the tree from being predictable.

### Child Key Derivation (CKD)

BIP-32 defines two types of child key derivation:

#### Normal (Non-Hardened) Child Derivation

```
Parent Public Key + Parent Chain Code + Index
    |
    v
HMAC-SHA512
    |
    v
[  Left 256 bits  |  Right 256 bits  ]
[  IL              |  IR              ]
    |                   |
    v                   v
Child Key =         Child Chain
(IL + Parent Key)   Code = IR
mod n
```

- Index range: 0 to 2^31 - 1
- Uses the parent PUBLIC key
- Anyone with the parent public key + chain code can derive child public keys
- This enables watch-only wallets

#### Hardened Child Derivation

```
0x00 + Parent Private Key + Parent Chain Code + (Index + 2^31)
    |
    v
HMAC-SHA512
    |
    v
[  Left 256 bits  |  Right 256 bits  ]
[  IL              |  IR              ]
    |                   |
    v                   v
Child Key =         Child Chain
(IL + Parent Key)   Code = IR
mod n
```

- Index range: 2^31 to 2^32 - 1 (denoted with ' or H, e.g., 44')
- Uses the parent PRIVATE key
- Prevents parent public key from deriving child keys
- More secure: compromising a child key cannot reveal the parent

### The Key Tree

```
                          m (master)
                         /    \
                        /      \
                 m/0'          m/1'
                / | \          / | \
              /   |   \      /   |   \
         m/0'/0 m/0'/1 ... m/1'/0 m/1'/1 ...
         / | \
        /  |  \
  m/0'/0/0  m/0'/0/1  m/0'/0/2 ...
```

Each node in the tree is a key pair (private + public) plus a chain code.
The ' symbol indicates hardened derivation.

---

## BIP-44: Multi-Account Hierarchy

**BIP-44** defines a specific tree structure for organizing keys across
multiple cryptocurrencies and accounts:

```
m / purpose' / coin_type' / account' / change / address_index

m/44'/60'/0'/0/0
 |   |    |   | |
 |   |    |   | +-- address_index: 0 (first address)
 |   |    |   +---- change: 0 (external/receiving)
 |   |    +-------- account: 0 (first account)
 |   +------------- coin_type: 60 (Ethereum)
 +----------------- purpose: 44 (BIP-44)
```

### Path Components Explained

#### Purpose (44')

Always 44' for BIP-44 compliant wallets. The hardened derivation
prevents cross-purpose key leakage.

Other purposes: 49' (BIP-49, segwit), 84' (BIP-84, native segwit)

#### Coin Type

Registered coin types from SLIP-44:

| Coin Type | Cryptocurrency |
|-----------|----------------|
| 0'        | Bitcoin        |
| 2'        | Litecoin       |
| 60'       | Ethereum       |
| 61'       | Ethereum Classic|
| 118'      | Cosmos (ATOM)  |
| 501'      | Solana         |
| 714'      | BNB            |

#### Account

Allows users to organize funds into separate accounts (like bank
accounts). Each account is independently derivable.

```
Account 0': Personal spending
Account 1': Business funds
Account 2': Savings
```

#### Change

- **0** (external): Receiving addresses shared with others
- **1** (internal): Change addresses for transaction outputs

Note: Ethereum typically only uses the external chain (0) since it
uses an account model rather than UTXO.

#### Address Index

Sequential index for generating multiple addresses within an account.

```
m/44'/60'/0'/0/0   -->  First receiving address
m/44'/60'/0'/0/1   -->  Second receiving address
m/44'/60'/0'/0/2   -->  Third receiving address
...
```

---

## Ethereum-Specific Derivation

### From Private Key to Ethereum Address

```
Private Key (256 bits)
    |
    v
+------------------------------------------+
| secp256k1 Elliptic Curve Multiplication  |
| Public Key = private_key * G             |
| (G is the generator point)              |
+------------------------------------------+
    |
    v
Uncompressed Public Key (512 bits / 64 bytes)
    04 || x-coordinate (256 bits) || y-coordinate (256 bits)
    |
    v  (strip the 04 prefix, use only x || y)
+------------------------------------------+
| Keccak-256 Hash                          |
| (NOT standard SHA-3, but the original    |
|  Keccak before NIST standardization)     |
+------------------------------------------+
    |
    v
256-bit Hash Output
    |
    v  (take the last 20 bytes / 160 bits)
+------------------------------------------+
| Last 20 bytes = Raw Address              |
| Example: d8da6bf26964af9d7eed9e03e534... |
+------------------------------------------+
    |
    v
+------------------------------------------+
| EIP-55 Checksum Encoding                |
| Mixed-case hex based on Keccak-256 hash |
| of the lowercase address                |
+------------------------------------------+
    |
    v
Ethereum Address:
    0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045
```

### EIP-55 Checksum Encoding

EIP-55 uses mixed-case hex to encode a checksum into the address:

```
1. Take lowercase address (without 0x):
   d8da6bf26964af9d7eed9e03e53415d37aa96045

2. Hash the lowercase address with Keccak-256:
   hash = keccak256("d8da6bf26964af9d7eed9e03e53415d37aa96045")
   hash = 4f3a9c... (example)

3. For each character in the address:
   - If it's a digit (0-9): keep as-is
   - If the corresponding hash nibble >= 8: uppercase
   - If the corresponding hash nibble < 8: lowercase

4. Result:
   0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045
      ^^ ^  ^         ^
      These are uppercase because their hash nibble >= 8
```

This provides ~15 bits of error detection with no additional storage.

---

## Complete Flow Diagram

```
+============================================================+
|               COMPLETE KEY DERIVATION FLOW                  |
+============================================================+

[1] ENTROPY GENERATION
    +-----------------------+
    | CSPRNG generates      |
    | 128-256 bits of       |
    | random data           |
    +-----------------------+
              |
              v
[2] BIP-39 MNEMONIC ENCODING
    +-----------------------+
    | Entropy + Checksum    |
    | split into 11-bit     |
    | groups, mapped to     |
    | wordlist              |
    +-----------------------+
    | "abandon abandon      |
    |  abandon ... about"   |
    +-----------------------+
              |
              v
[3] BIP-39 SEED DERIVATION
    +-----------------------+
    | PBKDF2-HMAC-SHA512   |
    | 2048 iterations      |
    | Salt: "mnemonic"     |
    |       + passphrase   |
    +-----------------------+
    | 512-bit seed          |
    | 5eb00bbddcf069...    |
    +-----------------------+
              |
              v
[4] BIP-32 MASTER KEY
    +-----------------------+
    | HMAC-SHA512           |
    | Key: "Bitcoin seed"   |
    +-----------------------+
    | Master Key  | Chain   |
    | (256 bits)  | Code    |
    |             |(256 bits)|
    +-----------------------+
              |
              v
[5] BIP-44 DERIVATION PATH
    m/44'/60'/0'/0/0

    m -----> m/44' -----> m/44'/60' -----> m/44'/60'/0'
   (root)  (purpose)   (coin_type)      (account)
                                            |
                                            v
                                     m/44'/60'/0'/0
                                       (change)
                                            |
                                            v
                                     m/44'/60'/0'/0/0
                                     (address_index)
              |
              v
[6] ETHEREUM ADDRESS
    +-----------------------+
    | Private Key           |
    |   -> secp256k1        |
    |   -> Public Key       |
    |   -> Keccak-256       |
    |   -> Last 20 bytes    |
    |   -> EIP-55 checksum  |
    +-----------------------+
    | 0xd8dA6BF26964aF9D...|
    +-----------------------+

+============================================================+
```

---

## Security Implications

### Why Hardened Derivation Matters

If an attacker obtains a non-hardened child private key AND the parent
chain code, they can compute the parent private key. Hardened derivation
prevents this by using the parent private key (not public key) in the
HMAC, making it impossible to work backwards.

```
NORMAL DERIVATION RISK:
    Child private key + Parent chain code
        --> Can compute parent private key!
        --> Can derive ALL sibling keys!

HARDENED DERIVATION:
    Child private key + Parent chain code
        --> CANNOT compute parent private key
        --> Sibling keys remain safe
```

This is why the first three levels of BIP-44 (purpose, coin_type,
account) all use hardened derivation.

### Why the 2048 PBKDF2 Iterations

The 2048 iterations in BIP-39 seed derivation provide:
- Computational cost to slow brute-force attacks
- Time to stretch low-entropy passphrases
- Standard adopted before more modern KDFs were available

Note: 2048 is relatively low by modern standards. The real security
comes from the mnemonic's entropy (128-256 bits), not the KDF.

### The Importance of Entropy Quality

The entire security of the HD wallet rests on the initial entropy:

```
Entropy bits   Possible combinations    Time to brute-force (10^12/sec)
-----------    ---------------------    --------------------------------
64 bits        ~1.8 * 10^19            ~5 hours
128 bits       ~3.4 * 10^38            ~10^14 years
256 bits       ~1.2 * 10^77            ~10^53 years
```

128 bits (12 words) is considered secure. 256 bits (24 words) provides
an extreme security margin.

---

> **REMINDER**: All mnemonics, keys, and addresses in this document and
> generated by the Crypto Wallet Explorer are for educational/testnet
> purposes ONLY. Never use them for real cryptocurrency.
